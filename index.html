<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planning Poker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js";
        import { getDatabase, ref, set, get, onValue, onDisconnect, serverTimestamp, update, remove } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyABZ2rEEwDsGUNQ475Iq_RzfqYlMqUEW-M",
            authDomain: "planningpoker-115b0.firebaseapp.com",
            databaseURL: "https://planningpoker-115b0-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "planningpoker-115b0",
            storageBucket: "planningpoker-115b0.appspot.com",
            messagingSenderId: "883176222007",
            appId: "1:883176222007:web:b18ea07bdf0733bd557eb2"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);

        // --- Global State ---
        let currentRoomId = null;
        let currentUserId = null;
        let currentUsername = null;
        let roomRef = null;
        let userRef = null;
        let usersRef = null;
        let stateRef = null;
        let kickedRef = null;
        let userDisconnectRef = null;
        let displayCountdownInterval = null; // For display-only countdown
        let revealWatchdogTimer = null; // For robust reveal state handling

        // Variables to hold listener unsubscribe functions
        let usersListenerUnsubscribe = null;
        let stateListenerUnsubscribe = null;
        let kickedListenerUnsubscribe = null;

        // --- UI Elements ---
        const loadingScreen = document.getElementById('loading-screen');
        const initialScreen = document.getElementById('initial-screen');
        const joinOverlay = document.getElementById('join-overlay');
        const joinScreenContent = document.getElementById('join-screen-content');
        const joinScreenTitle = joinScreenContent.querySelector('h2');
        const roomScreen = document.getElementById('room-screen');
        const kickedScreen = document.getElementById('kicked-screen');

        const roomNameInput = document.getElementById('room-name');
        const createRoomBtn = document.getElementById('create-room-btn');

        const usernameInput = joinScreenContent.querySelector('#username');
        const joinRoomBtn = joinScreenContent.querySelector('#join-room-btn');

        const roomTitle = document.getElementById('room-title');
        const participantsList = document.getElementById('participants-list');
        const votingCards = document.getElementById('voting-cards');
        const revealBtn = document.getElementById('reveal-btn');
        const resetBtn = document.getElementById('reset-btn');
        const resultsSummary = document.getElementById('results-summary');
        const copyLinkBtn = document.getElementById('copy-link-btn');
        const inviteLinkDisplay = document.getElementById('invite-link-display');

        const cardSetSelect = document.getElementById('card-set-select');
        const customCardValuesInput = document.getElementById('custom-card-values');

        // --- Poker Cards ---
        const cardValues = ['0', '0.5', '1', '2', '3', '5', '8', '?', '☕'];

        // --- Helper Functions ---
        function showScreen(screenElement) {
            loadingScreen.classList.add('hidden');
            initialScreen.classList.add('hidden');
            roomScreen.classList.add('hidden');
            kickedScreen.classList.add('hidden');
            screenElement.classList.remove('hidden');
        }

        function showJoinOverlay() {
            if (currentRoomId) {
                const roomNameRef = ref(db, `rooms/${currentRoomId}/name`);
                get(roomNameRef).then(snapshot => {
                    const roomName = snapshot.val();
                    joinScreenTitle.textContent = roomName ? `Raum beitreten` : 'Raum beitreten';
                }).catch(error => {
                    console.error("Fehler beim Abrufen des Raumnamens für Overlay:", error);
                    joinScreenTitle.textContent = 'Raum beitreten';
                });
            } else {
                 joinScreenTitle.textContent = 'Raum beitreten';
            }
            joinOverlay.classList.remove('hidden');
            joinOverlay.classList.add('flex');
            usernameInput.focus();
        }

        function hideJoinOverlay() {
            joinOverlay.classList.add('hidden');
            joinOverlay.classList.remove('flex');
        }

        function generateRoomId(length = 6) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                inviteLinkDisplay.textContent = 'Link kopiert!';
                inviteLinkDisplay.classList.remove('hidden');
                setTimeout(() => {
                    inviteLinkDisplay.classList.add('hidden');
                }, 2000);
            }).catch(err => {
                console.error('Fehler beim Kopieren des Links: ', err);
                inviteLinkDisplay.textContent = 'Kopieren fehlgeschlagen';
                inviteLinkDisplay.classList.remove('hidden');
                 setTimeout(() => {
                    inviteLinkDisplay.classList.add('hidden');
                }, 2000);
            });
        }

        // --- Firebase Logic ---

        // 1. Authentication
        function initializeAuth() {
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUserId = user.uid;
                    console.log("Angemeldet als:", currentUserId);
                    monitorConnectionState();
                    checkUrlForRoom();
                } else {
                    signInAnonymously(auth).catch((error) => {
                        console.error("Fehler bei anonymer Anmeldung:", error);
                        alert("Anmeldung bei Firebase fehlgeschlagen. Bitte Seite neu laden.");
                    });
                }
            });
        }

        let isInitialConnect = true;
        function monitorConnectionState() {
            const connectedRef = ref(db, '.info/connected');
            onValue(connectedRef, (snap) => {
                const isConnected = snap.val();
                if (isConnected === true) {
                    console.log("Verbunden mit Firebase.");
                    if (isInitialConnect) {
                        isInitialConnect = false;
                        return;
                    }
                    if (userRef) {
                        console.log("Wieder verbunden. Setze online: true und onDisconnect neu.");
                        update(userRef, { online: true })
                            .catch(err => console.error("Fehler beim Setzen von online=true bei Wiederverbindung:", err));

                        userDisconnectRef = onDisconnect(userRef);
                        userDisconnectRef.update({ online: false })
                            .catch(err => console.error("Fehler beim erneuten Setzen von onDisconnect:", err));
                    }
                } else {
                    console.log("Verbindung zu Firebase getrennt.");
                    isInitialConnect = false;
                }
            });
        }

        // 2. Check URL for Room ID
        async function checkUrlForRoom() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                currentRoomId = hash;
                roomRef = ref(db, `rooms/${currentRoomId}`);
                usersRef = ref(db, `rooms/${currentRoomId}/users`);
                stateRef = ref(db, `rooms/${currentRoomId}/state`);
                kickedRef = ref(db, `rooms/${currentRoomId}/kicked/${currentUserId}`);

                const checkRoomRef = ref(db, `rooms/${currentRoomId}`);
                get(checkRoomRef).then(async (snapshot) => {
                    if (snapshot.exists()) {
                        const checkKickedRef = ref(db, `rooms/${currentRoomId}/kicked/${currentUserId}`);
                        get(checkKickedRef).then(async kickedSnapshot => {
                            if (kickedSnapshot.exists()) {
                                console.log(`User ${currentUserId} is kicked from room ${currentRoomId}. Showing kicked screen directly.`);
                                showScreen(kickedScreen);
                            } else {
                                console.log(`Room ${currentRoomId} found, user not kicked. Showing room and join overlay.`);
                                showScreen(roomScreen);
                                updateRoomUI();
                                setupRoomListeners(currentRoomId);
                                await renderVotingCards();
                                showJoinOverlay();
                            }
                        }).catch(async error => {
                             console.error("Error checking kicked status:", error);
                             console.log(`Error checking kick status for room ${currentRoomId}. Proceeding to join overlay.`);
                             showScreen(roomScreen); 
                             updateRoomUI(); 
                             setupRoomListeners(currentRoomId);
                             await renderVotingCards();
                             showJoinOverlay(); 
                        });
                    } else {
                        console.warn(`Raum ${currentRoomId} nicht gefunden.`);
                        window.location.hash = '';
                        hideJoinOverlay();
                        showScreen(initialScreen);
                        roomNameInput.focus();
                    }
                }).catch(error => {
                    console.error("Fehler beim Prüfen des Raums:", error);
                    hideJoinOverlay();
                    showScreen(initialScreen);
                    roomNameInput.focus();
                });
            } else {
                hideJoinOverlay();
                showScreen(initialScreen);
                roomNameInput.focus();
            }
        }

        // 3. Create Room
        async function createRoom() {
            const roomName = roomNameInput.value.trim();
            if (!roomName || !currentUserId) return;

            currentRoomId = generateRoomId();
            const newRoomRef = ref(db, `rooms/${currentRoomId}`);
            
            let cardSetConfig = { type: cardSetSelect.value };
            if (cardSetSelect.value === 'custom') {
                const customValues = customCardValuesInput.value.split(',').map(v => v.trim()).filter(v => v);
                if (customValues.length > 0) {
                    cardSetConfig.values = customValues;
                } else {
                    cardSetConfig.type = 'default'; 
                }
            }

            try {
                await set(newRoomRef, {
                    name: roomName,
                    createdAt: serverTimestamp(),
                    state: {
                        votesRevealed: false,
                        revealState: 'idle'
                    },
                    users: {},
                    kicked: {},
                    cardSetConfig: cardSetConfig
                });
                console.log("Raum erstellt:", currentRoomId, "mit Kartensatz:", cardSetConfig);
                window.location.hash = currentRoomId;

                roomRef = ref(db, `rooms/${currentRoomId}`);
                usersRef = ref(db, `rooms/${currentRoomId}/users`);
                stateRef = ref(db, `rooms/${currentRoomId}/state`);

                showScreen(roomScreen);

                updateRoomUI();
                const newKickedRef = ref(db, `rooms/${currentRoomId}/kicked/${currentUserId}`);
                 if (usersRef && stateRef && newKickedRef) {
                    setupRoomListeners(currentRoomId);
                 } else {
                    console.error("Refs not ready for initial listener setup in createRoom");
                 }
                await renderVotingCards();

                showJoinOverlay();

            } catch (error) {
                console.error("Fehler beim Erstellen des Raums:", error);
                alert("Raum konnte nicht erstellt werden.");
                hideJoinOverlay();
                showScreen(initialScreen);
            }
        }

        // 4. Join Room
        async function joinRoom() {
            const username = usernameInput.value.trim();
            if (!username || !currentUserId || !currentRoomId) return;

            currentUsername = username;
            roomRef = ref(db, `rooms/${currentRoomId}`);
            usersRef = ref(db, `rooms/${currentRoomId}/users`);
            userRef = ref(db, `rooms/${currentRoomId}/users/${currentUserId}`);
            stateRef = ref(db, `rooms/${currentRoomId}/state`);
            kickedRef = ref(db, `rooms/${currentRoomId}/kicked/${currentUserId}`);

            try {
                const userDataToWrite = {
                    name: currentUsername,
                    vote: null,
                    online: true
                };

                const kickedSnapshot = await get(ref(db, `rooms/${currentRoomId}/kicked/${currentUserId}`));
                if (kickedSnapshot.exists()) {
                    console.log("User is currently kicked. Showing kicked screen.");
                    hideJoinOverlay();
                    showScreen(kickedScreen);
                    return;
                }

                await set(userRef, userDataToWrite);
                userDisconnectRef = onDisconnect(userRef);
                userDisconnectRef.update({ online: false });

                console.log(`${currentUsername} (${currentUserId}) dem Raum ${currentRoomId} beigetreten.`);
                hideJoinOverlay();
                showScreen(roomScreen);

                if (currentRoomId) {
                    setupRoomListeners(currentRoomId);
                } else {
                    console.error("currentRoomId not available for listener setup in joinRoom.");
                }
                await renderVotingCards();
                updateRoomUI();
            } catch (error) {
                console.error("Fehler beim Beitreten zum Raum:", error);
                alert("Beitritt zum Raum fehlgeschlagen.");
                hideJoinOverlay();
                window.location.hash = '';
                showScreen(initialScreen);
                roomNameInput.focus();
            }
        }

        // 5. Setup Room Listeners
        function setupRoomListeners(roomId) {
            console.log(`Setting up listeners for room: ${roomId}`);

            if (!roomId) {
                console.error("Missing roomId for setupRoomListeners");
                return;
            }

            const usersPath = `rooms/${roomId}/users`;
            const statePath = `rooms/${roomId}/state`;
            const kickedPath = `rooms/${roomId}/kicked/${currentUserId}`;

            if (!currentUserId) {
                console.error("Cannot setup kicked listener without currentUserId");
            }

            const currentUsersRef = ref(db, usersPath);
            const currentStateRef = ref(db, statePath);
            const currentKickedRef = currentUserId ? ref(db, kickedPath) : null;

            // --- Users Listener ---
            const usersUnsubscribe = onValue(currentUsersRef, (snapshot) => {
                const capturedStateRefForUsersListener = stateRef;
                const users = snapshot.val() || {};

                if (!capturedStateRefForUsersListener) {
                    console.warn("Users listener fired with null capturedStateRef, skipping state fetch.");
                    renderParticipants(users, false);
                    updateResults(users);
                    if (users[currentUserId]) {
                        updateUserVoteHighlight(users[currentUserId].vote);
                    }
                    return;
                }

                get(capturedStateRefForUsersListener).then(stateSnapshot => {
                    const state = stateSnapshot.val() || { votesRevealed: false, revealState: 'idle' };
                    renderParticipants(users, state.votesRevealed);
                    updateResults(users);
                    if (users[currentUserId]) {
                        updateUserVoteHighlight(users[currentUserId].vote);
                    }
                }).catch(error => console.error("Error fetching state in users listener:", error));
            });

            // --- State Listener (MODIFIED FOR ROBUST REVEAL) ---
            const stateUnsubscribe = onValue(currentStateRef, (snapshot) => {
                const capturedUsersRefForStateListener = usersRef;
                const capturedUserRefForStateListener = userRef;
                
                const state = snapshot.val() || { votesRevealed: false, revealState: 'idle' };

                // Handle UI updates based on state
                updateButtonAndCountdownUI(state);
                updateResultsVisibility(state.votesRevealed);

                // Start or stop the watchdog timer based on the state
                if (state.revealState === 'counting') {
                    // Clear any previous timer
                    if (revealWatchdogTimer) clearTimeout(revealWatchdogTimer);

                    // Set a watchdog: if after 5 seconds the state is still 'counting', reset it.
                    revealWatchdogTimer = setTimeout(() => {
                        console.log("Watchdog triggered: Checking reveal state...");
                        get(currentStateRef).then(snap => {
                            const currentState = snap.val();
                            if (currentState && currentState.revealState === 'counting') {
                                console.warn("Reveal state stuck on 'counting'. Resetting to 'idle'.");
                                update(currentStateRef, { revealState: 'idle', votesRevealed: false, revealStartedAt: null });
                            }
                        });
                    }, 5000); // 5-second safety net
                } else {
                    // If state is not 'counting', clear any running watchdog
                    if (revealWatchdogTimer) {
                        clearTimeout(revealWatchdogTimer);
                        revealWatchdogTimer = null;
                    }
                }
                
                // Fetch users to update participant cards
                if (capturedUsersRefForStateListener) {
                    get(capturedUsersRefForStateListener).then(userSnapshot => {
                        const users = userSnapshot.val() || {};
                        renderParticipants(users, state.votesRevealed);
                    }).catch(error => console.error("Error fetching users in state listener:", error));
                } else {
                    renderParticipants({}, state.votesRevealed);
                }

                if (state.votesRevealed) {
                    updateResults(null);
                } else {
                    resultsSummary.classList.add('hidden');
                    if (capturedUserRefForStateListener) {
                        get(capturedUserRefForStateListener).then(userSnapshot => {
                            const userData = userSnapshot.val();
                            updateUserVoteHighlight(userData ? userData.vote : null);
                        }).catch(error => console.error("Error fetching user data in state listener:", error));
                    } else {
                        updateUserVoteHighlight(null);
                    }
                }
            });

            // --- Kicked Listener ---
             const kickedUnsubscribe = onValue(currentKickedRef, (snapshot) => {
                if (snapshot.exists()) {
                    console.log("Du wurdest aus dem Raum geworfen.");
                    showScreen(kickedScreen);
                    if (userDisconnectRef) {
                        userDisconnectRef.cancel();
                    }
                    if (userRef) {
                       remove(userRef).catch(err => console.error("Fehler beim Entfernen des Benutzers nach Kick:", err));
                    }
                }
            });

            usersListenerUnsubscribe = usersUnsubscribe;
            stateListenerUnsubscribe = stateUnsubscribe;
            kickedListenerUnsubscribe = kickedUnsubscribe;
            console.log("Listeners attached and unsubscribe handles stored.");
        }

        // 6. Render UI Elements
        async function renderVotingCards() {
            votingCards.innerHTML = '';
            let currentCardValues = [...cardValues];

            if (currentRoomId) {
                const roomCardSetConfigRef = ref(db, `rooms/${currentRoomId}/cardSetConfig`);
                try {
                    const snapshot = await get(roomCardSetConfigRef);
                    if (snapshot.exists()) {
                        const config = snapshot.val();
                        console.log("Room cardSetConfig found:", config);
                        if (config.type === 'default') {
                            currentCardValues = ['0', '0.5', '1', '2', '3', '5', '8', '?', '☕'];
                        } else if (config.type === 'modified_fibonacci') {
                            currentCardValues = ['0', '0.5', '1', '2', '3', '5', '8', '13', '20', '40', '100', '?', '☕'];
                        } else if (config.type === 'fibonacci') {
                            currentCardValues = ['0', '1', '2', '3', '5', '8', '13', '21', '34', '55', '89', '?', '☕'];
                        } else if (config.type === 'tshirts') {
                            currentCardValues = ['XS', 'S', 'M', 'L', 'XL', '?', '☕'];
                        } else if (config.type === 'custom' && config.values && config.values.length > 0) {
                            currentCardValues = config.values;
                        } else {
                            console.warn("Unrecognized or invalid cardSetConfig, using default. Config:", config);
                        }
                    } else {
                        console.log("No cardSetConfig found for room, using default.");
                    }
                } catch (error) {
                    console.error("Error fetching cardSetConfig, using default:", error);
                }
            }

            currentCardValues.forEach(value => {
                const button = document.createElement('button');
                button.textContent = value;
                button.dataset.value = value;
                button.className = 'bg-white hover:bg-gray-100 text-gray-800 font-semibold py-2 px-1 border border-gray-400 rounded-lg shadow text-lg transition duration-150 ease-in-out focus:outline-none w-[50px] h-[80px] flex items-center justify-center';
                button.onclick = handleVote;
                votingCards.appendChild(button);
            });
        }

        function renderParticipants(usersData, votesRevealed) {
             if (!usersData) {
                participantsList.innerHTML = '<div class="text-gray-500 italic whitespace-nowrap">Warte auf Teilnehmer...</div>';
                return;
             }

             const users = usersData;
             participantsList.innerHTML = '';
             const onlineUserIds = Object.keys(users).filter(uid => users[uid] && users[uid].online);

             if (onlineUserIds.length === 0) {
                 participantsList.innerHTML = '<div class="text-gray-500 italic whitespace-nowrap">Keine aktiven Teilnehmer.</div>';
                 return;
             }

             Object.entries(users).forEach(([userId, userData]) => {
                 if (!userData || !userData.online) return;

                 const participantDiv = document.createElement('div');
                 participantDiv.className = 'relative group bg-white p-1 rounded-lg shadow border border-gray-200 flex flex-col items-center justify-center w-[50px] h-[80px] text-center m-2';

                 const nameSpan = document.createElement('span');
                 nameSpan.textContent = userData.name || 'Unbekannt';
                 nameSpan.className = 'text-xs font-medium text-gray-600 mb-1 absolute -top-5 left-1/2 transform -translate-x-1/2 px-1 whitespace-nowrap';
                 participantDiv.appendChild(nameSpan);

                 const cardContentDiv = document.createElement('div');
                 cardContentDiv.className = 'flex flex-col items-center justify-center h-full';

                 if (votesRevealed) {
                     if (userData.vote === null || typeof userData.vote === 'undefined') {
                         const displayVote = (userData.vote === null || typeof userData.vote === 'undefined') ? '-' : userData.vote;
                         cardContentDiv.innerHTML = `<span class="text-2xl font-bold text-gray-500">${displayVote}</span>`;
                         participantDiv.classList.remove('bg-white', 'bg-indigo-600');
                         participantDiv.classList.add('bg-gray-200', 'border-gray-300');
                     } else {
                         const displayVote = (userData.vote === null || typeof userData.vote === 'undefined') ? '-' : userData.vote;
                         cardContentDiv.innerHTML = `<span class="text-2xl font-bold text-white">${displayVote}</span>`;
                         participantDiv.classList.remove('bg-white', 'bg-gray-200', 'border-gray-300');
                         participantDiv.classList.add('bg-indigo-600');
                     }
                 } else {
                    participantDiv.classList.remove('bg-indigo-600', 'border-indigo-700', 'bg-gray-200', 'border-gray-300', 'border-indigo-500');

                     if (userData.vote !== null && typeof userData.vote !== 'undefined') {
                         cardContentDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;
                         participantDiv.classList.remove('bg-white');
                         participantDiv.classList.add('bg-indigo-600', 'border-indigo-700');
                     } else {
                         cardContentDiv.innerHTML = `<span class="text-2xl font-bold text-[#4b5563]">?</span>`;
                         participantDiv.classList.remove('bg-white');
                         participantDiv.classList.add('bg-gray-200', 'border-gray-300');
                     }
                 }
                 participantDiv.appendChild(cardContentDiv);

                 if (userId !== currentUserId) {
                     const kickButton = document.createElement('button');
                     kickButton.innerHTML = '&times;';
                     kickButton.className = 'absolute top-0 right-1 text-red-500 hover:text-red-700 opacity-0 group-hover:opacity-100 transition-opacity text-lg font-bold leading-none';
                     kickButton.title = `${userData.name} entfernen`;
                     kickButton.onclick = (e) => {
                         e.stopPropagation();
                         if (confirm(`Möchtest du ${userData.name} wirklich aus dem Raum entfernen?`)) {
                             kickUser(userId);
                         }
                     };
                     participantDiv.appendChild(kickButton);
                 }

                 participantsList.appendChild(participantDiv);
             });
        }
        
        function updateRoomUI() {
            get(ref(db, `rooms/${currentRoomId}/name`)).then(snapshot => {
                roomTitle.textContent = `Raum: ${snapshot.val() || 'Unbenannter Raum'}`;
            });

            copyLinkBtn.onclick = () => {
                const inviteLink = `${window.location.origin}${window.location.pathname}#${currentRoomId}`;
                copyToClipboard(inviteLink);
            };
        }

        // --- Update UI based on Room State ---
        function updateButtonAndCountdownUI(state) {
            const { votesRevealed, revealState, revealStartedAt } = state;

            if (displayCountdownInterval) {
                clearInterval(displayCountdownInterval);
                displayCountdownInterval = null;
            }

            if (revealState === 'counting' && revealStartedAt) {
                resetBtn.classList.add('hidden');
                revealBtn.classList.remove('hidden');
                revealBtn.disabled = true;
                revealBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                revealBtn.classList.add('bg-indigo-500');

                // Start synchronized local display countdown
                displayCountdownInterval = setInterval(() => {
                    const elapsed = Date.now() - revealStartedAt;
                    const remainingSeconds = Math.max(0, 3 - Math.floor(elapsed / 1000));
                    
                    if (remainingSeconds > 0) {
                        revealBtn.textContent = `Aufdecken in ${remainingSeconds}...`;
                    } else {
                        // The state listener will handle the switch to the revealed state.
                        // We can just show a generic message while waiting for the state change.
                        revealBtn.textContent = `Aufdecken...`;
                        clearInterval(displayCountdownInterval);
                        displayCountdownInterval = null;
                    }
                }, 250); // Update 4 times a second for smoother countdown start

            } else if (votesRevealed || revealState === 'revealed') {
                revealBtn.classList.add('hidden');
                resetBtn.classList.remove('hidden');
                revealBtn.disabled = false;
                revealBtn.textContent = 'Stimmen aufdecken';
                revealBtn.classList.remove('bg-indigo-500');
                revealBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            } else { // Idle state
                revealBtn.classList.remove('hidden');
                resetBtn.classList.add('hidden');
                revealBtn.disabled = false;
                revealBtn.textContent = 'Stimmen aufdecken';
                revealBtn.classList.remove('bg-indigo-500');
                revealBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }
        }

        function updateResultsVisibility(votesRevealed) {
            if (votesRevealed) {
                resultsSummary.classList.remove('hidden');
            } else {
                resultsSummary.classList.add('hidden');
            }
        }

       function updateResults(usersData) {
           const currentUpdateStateRef = stateRef;
           const currentUpdateUsersRef = usersRef;

           if (!currentUpdateStateRef || !currentUpdateUsersRef) {
               console.warn("updateResults called with null refs, hiding results.");
               resultsSummary.classList.add('hidden');
               return;
           }

           get(currentUpdateStateRef).then(stateSnapshot => {
               const state = stateSnapshot.val() || { votesRevealed: false };
               if (!state.votesRevealed) {
                   resultsSummary.classList.add('hidden');
                   return;
               }

               const fetchUsers = usersData ? Promise.resolve(usersData) : get(currentUpdateUsersRef).then(s => s.val() || {});

               fetchUsers.then(users => {
                   let sum = 0;
                   let numericVoteCount = 0;
                   let nullOrUndefinedVoteCount = 0;
                   const voteCounts = {};
                   const validVotes = [];

                   Object.values(users).forEach(user => {
                       if (user.online) {
                           if (user.vote === null || typeof user.vote === 'undefined') {
                               nullOrUndefinedVoteCount++;
                           } else {
                               const vote = user.vote;
                               voteCounts[vote] = (voteCounts[vote] || 0) + 1;

                               const numericVote = parseFloat(vote);
                               if (!isNaN(numericVote)) {
                                   sum += numericVote;
                                   numericVoteCount++;
                                   validVotes.push(numericVote);
                               }
                           }
                       }
                   });

                   if (nullOrUndefinedVoteCount > 0) {
                       voteCounts['-'] = nullOrUndefinedVoteCount;
                   }

                   resultsSummary.innerHTML = '';
                   resultsSummary.className = 'mb-4 p-3 bg-gray-50 border border-gray-200 rounded-md text-center';

                   if (numericVoteCount > 0) {
                       const average = (sum / numericVoteCount).toFixed(1);
                       const minVote = Math.min(...validVotes);
                       const maxVote = Math.max(...validVotes);

                       const avgContainer = document.createElement('div');
                       avgContainer.className = 'mb-2';
                       const avgLabel = document.createElement('p');
                       avgLabel.textContent = 'Durchschnitt';
                       avgLabel.className = 'text-sm text-gray-600';
                       avgContainer.appendChild(avgLabel);
                       const avgElement = document.createElement('p');
                       avgElement.innerHTML = `<span class="font-bold text-4xl">${average}</span>`;
                       avgContainer.appendChild(avgElement);
                       resultsSummary.appendChild(avgContainer);

                       const rangeElement = document.createElement('p');
                       rangeElement.className = 'text-sm text-gray-600 mb-1';
                       rangeElement.textContent = `(Min: ${minVote}, Max: ${maxVote})`;
                       resultsSummary.appendChild(rangeElement);

                       if (minVote === maxVote && numericVoteCount > 1) {
                           const consensusElement = document.createElement('p');
                           consensusElement.className = 'text-sm text-green-600 font-semibold mb-2';
                           consensusElement.textContent = `Konsens erreicht!`;
                           resultsSummary.appendChild(consensusElement);
                           triggerFireworks();
                       }
                   } else {
                       if (Object.keys(voteCounts).length > 0) {
                           const nonNumericMsg = document.createElement('p');
                           nonNumericMsg.className = 'mb-4 text-gray-700';
                           nonNumericMsg.textContent = 'Keine numerischen Stimmen abgegeben.';
                           resultsSummary.appendChild(nonNumericMsg);
                       } else {
                           const noVotesElement = document.createElement('p');
                           noVotesElement.textContent = 'Keine Stimmen abgegeben.';
                           resultsSummary.appendChild(noVotesElement);
                       }
                   }
                   
                   const divider = document.createElement('div');
                   divider.className = 'w-full border-t border-gray-300 my-4';
                   resultsSummary.appendChild(divider);

                   if (Object.keys(voteCounts).length > 0) {
                       const distributionContainer = document.createElement('div');
                       distributionContainer.className = 'flex justify-center items-end gap-4 mt-1 mb-1 min-h-[160px]';

                       const sortedVoteKeys = Object.keys(voteCounts).sort((a, b) => {
                           const numA = parseFloat(a);
                           const numB = parseFloat(b);
                           if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                           if (!isNaN(numA)) return -1;
                           if (!isNaN(numB)) return 1;
                           if (a === '-') return -1;
                           if (b === '-') return 1;
                           return a.localeCompare(b);
                       });

                       const castVoteCounts = Object.entries(voteCounts)
                           .filter(([vote]) => vote !== '-')
                           .map(([, count]) => count);
                       const maxCount = castVoteCounts.length > 0 ? Math.max(...castVoteCounts) : 0;

                       let totalParticipantsIncludingNoVote = 0;
                       Object.values(voteCounts).forEach(count => {
                           totalParticipantsIncludingNoVote += count;
                       });

                       sortedVoteKeys.forEach(vote => {
                           const count = voteCounts[vote];
                           const isMax = count === maxCount && maxCount > 0;
                           const barColorClass = isMax ? 'bg-gray-700' : 'bg-gray-400';
                           const cardBorderColorClass = isMax ? 'border-gray-700' : 'border-gray-400';
                           const textColorClass = isMax ? 'text-gray-800' : 'text-gray-500';
                           const countTextColorClass = isMax ? 'text-gray-800' : 'text-gray-500';

                           const barWrapper = document.createElement('div');
                           barWrapper.className = 'flex flex-col items-center w-[50px]';

                           const barOuter = document.createElement('div');
                           barOuter.className = 'relative w-2 h-[80px] bg-gray-200 rounded-md overflow-hidden';
                           barOuter.title = `${((count / totalParticipantsIncludingNoVote) * 100).toFixed(1)}%`;
                           const barInner = document.createElement('div');
                           barInner.className = `absolute bottom-0 left-0 w-full ${barColorClass} rounded-md`;
                           barInner.style.height = `${(count / totalParticipantsIncludingNoVote) * 100}%`;
                           barOuter.appendChild(barInner);
                           barWrapper.appendChild(barOuter);

                           const card = document.createElement('div');
                           card.className = `bg-white mt-2 p-1 rounded-lg shadow border ${cardBorderColorClass} flex items-center justify-center w-[50px] h-[80px] text-center`;
                           const voteValueSpan = document.createElement('span');
                           voteValueSpan.textContent = vote;
                           voteValueSpan.className = `text-2xl font-bold ${textColorClass}`;
                           card.appendChild(voteValueSpan);
                           barWrapper.appendChild(card);

                           const voteCountSpan = document.createElement('span');
                           voteCountSpan.textContent = `${count} Stimme${count !== 1 ? 'n' : ''}`;
                           voteCountSpan.className = `text-xs ${countTextColorClass} whitespace-nowrap mt-1`;
                           barWrapper.appendChild(voteCountSpan);
                           
                           distributionContainer.appendChild(barWrapper);
                       });
                       resultsSummary.appendChild(distributionContainer);
                   }
                   
                   resultsSummary.classList.remove('hidden');
               }).catch(error => console.error("Fehler beim Abrufen der Benutzerdaten für Ergebnisse:", error));
           }).catch(error => console.error("Fehler beim Abrufen des Raumstatus für Ergebnisse:", error));
       }

        function triggerFireworks() {
            const container = document.getElementById('fireworks-container');
            if (!container) return;

            container.classList.remove('hidden');
            container.innerHTML = '';

            const numBursts = 10;
            const particlesPerBurst = 40;
            const animationDuration = 800;
            const totalDuration = 1500;

            for (let i = 0; i < numBursts; i++) {
                setTimeout(() => {
                    const burstX = Math.random() * window.innerWidth;
                    const burstY = Math.random() * window.innerHeight * 0.7;
                    const hue = Math.random() * 360;

                    for (let j = 0; j < particlesPerBurst; j++) {
                        const particle = document.createElement('div');
                        particle.className = 'firework-particle';
                        particle.style.left = `${burstX}px`;
                        particle.style.top = `${burstY}px`;
                        particle.style.setProperty('--hue', hue);

                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 100 + 50;
                        const tx = Math.cos(angle) * distance;
                        const ty = Math.sin(angle) * distance;

                        particle.style.setProperty('--tx', `${tx}px`);
                        particle.style.setProperty('--ty', `${ty}px`);
                        container.appendChild(particle);

                        setTimeout(() => particle.remove(), animationDuration);
                    }
                }, Math.random() * (totalDuration - animationDuration));
            }

            setTimeout(() => {
                container.classList.add('hidden');
                container.innerHTML = '';
            }, totalDuration);
        }

        function updateUserVoteHighlight(currentUserVote) {
            document.querySelectorAll('#voting-cards button').forEach(btn => {
                btn.classList.remove('bg-indigo-600', 'text-white', 'hover:bg-indigo-700');
                btn.classList.add('bg-white', 'hover:bg-gray-100', 'text-gray-800');

                if (btn.dataset.value === currentUserVote && currentUserVote !== null) {
                    btn.classList.remove('bg-white', 'hover:bg-gray-100', 'text-gray-800');
                    btn.classList.add('bg-indigo-600', 'text-white', 'hover:bg-indigo-700');
                }
            });
        }

        // 7. Event Handlers
        function handleVote(event) {
            const selectedButton = event.target;
            const selectedValue = selectedButton.dataset.value;
            if (!userRef) return;

            const isCurrentlySelected = selectedButton.classList.contains('bg-indigo-600');
            const newValue = isCurrentlySelected ? null : selectedValue;

            update(userRef, { vote: newValue })
                .then(() => {
                    console.log(`Stimme auf ${newValue === null ? 'null' : newValue} geändert.`);
                    // The onValue listener for users will now handle the UI update automatically.
                    // This local update is a good optimistic update but not strictly necessary.
                    updateUserVoteHighlight(newValue); 
                })
                .catch(error => console.error("Fehler beim Abgeben/Ändern der Stimme:", error));
        }

        // MODIFIED for robustness
        function handleRevealVotes() {
            if (!stateRef) return;

            // Initiator starts the process atomically with a server timestamp
            update(stateRef, { 
                revealState: 'counting', 
                votesRevealed: false,
                revealStartedAt: serverTimestamp() 
            })
            .then(() => {
                console.log("Countdown gestartet (State: counting).");
                // The initiator is responsible for finishing the process after 3 seconds.
                // If they disconnect, the watchdog on other clients will reset the state.
                setTimeout(() => {
                    // Before updating, check if we are still in the 'counting' state.
                    // This prevents overwriting a state that was reset by the watchdog.
                    get(stateRef).then(snap => {
                        const currentState = snap.val();
                        if (currentState && currentState.revealState === 'counting') {
                            update(stateRef, { revealState: 'revealed', votesRevealed: true })
                                .then(() => console.log("Stimmen aufgedeckt (State: revealed)."))
                                .catch(error => {
                                    console.error("Fehler beim Setzen des revealed State:", error);
                                    // Try to reset state back to idle on error
                                    update(stateRef, { revealState: 'idle', votesRevealed: false, revealStartedAt: null });
                                });
                        } else {
                            console.log("Reveal process was aborted or reset by another client. No action taken.");
                        }
                    });
                }, 3000);
            })
            .catch(error => {
                console.error("Fehler beim Setzen des counting State:", error);
            });
            // All UI updates are now handled by the central state listener.
        }

        // MODIFIED for robustness
        function handleResetVotes() {
            if (!stateRef || !usersRef) return;

            // Clear any lingering timers
            if (displayCountdownInterval) clearInterval(displayCountdownInterval);
            if (revealWatchdogTimer) clearTimeout(revealWatchdogTimer);
            displayCountdownInterval = null;
            revealWatchdogTimer = null;

            // Update Firebase state to idle and clear the timestamp
            update(stateRef, { 
                revealState: 'idle', 
                votesRevealed: false,
                revealStartedAt: null 
            })
            .then(() => console.log("Abstimmung zurückgesetzt (State: idle)."))
            .catch(error => console.error("Fehler beim Zurücksetzen des Status:", error));

            // Clear votes in Firebase
            get(usersRef).then(snapshot => {
                const users = snapshot.val() || {};
                const updates = {};
                Object.keys(users).forEach(userId => {
                    updates[`/${userId}/vote`] = null;
                });
                if (Object.keys(updates).length > 0) {
                    update(usersRef, updates)
                        .then(() => console.log("Alle Stimmen zurückgesetzt."))
                        .catch(error => console.error("Fehler beim Zurücksetzen der Stimmen:", error));
                }
            });

            // Visually reset local user's voting cards
            updateUserVoteHighlight(null);
        }

        function kickUser(userIdToKick) {
            if (!currentRoomId || !userIdToKick) return;

            console.log(`Versuche ${userIdToKick} zu kicken.`);
            const userToRemoveRef = ref(db, `rooms/${currentRoomId}/users/${userIdToKick}`);
            const kickFlagRef = ref(db, `rooms/${currentRoomId}/kicked/${userIdToKick}`);

            set(kickFlagRef, true)
                .then(() => {
                    console.log(`Kick-Flag für ${userIdToKick} gesetzt.`);
                    return remove(userToRemoveRef);
                })
                .then(() => {
                    console.log(`Benutzer ${userIdToKick} erfolgreich entfernt.`);
                })
                .catch(error => {
                    console.error(`Fehler beim Kicken von Benutzer ${userIdToKick}:`, error);
                });
        }

        // 8. Cleanup
        function cleanupFirebaseListeners() {
            console.log("Cleaning up Firebase listeners...");
            if (typeof userDisconnectRef?.cancel === 'function') {
                console.log("- Cancelling onDisconnect handler");
                userDisconnectRef.cancel();
            }
            if (typeof usersListenerUnsubscribe === 'function') {
                console.log("- Detaching users listener");
                usersListenerUnsubscribe();
            }
            if (typeof stateListenerUnsubscribe === 'function') {
                console.log("- Detaching state listener");
                stateListenerUnsubscribe();
            }
            if (typeof kickedListenerUnsubscribe === 'function') {
                console.log("- Detaching kicked listener");
                kickedListenerUnsubscribe();
            }
            // Clear timers
            if (displayCountdownInterval) clearInterval(displayCountdownInterval);
            if (revealWatchdogTimer) clearTimeout(revealWatchdogTimer);

            // Null out globals
            userDisconnectRef = null;
            usersListenerUnsubscribe = null;
            stateListenerUnsubscribe = null;
            kickedListenerUnsubscribe = null;
            displayCountdownInterval = null;
            revealWatchdogTimer = null;
            currentRoomId = null;
            currentUsername = null;
            roomRef = null;
            userRef = null;
            usersRef = null;
            stateRef = null;
            kickedRef = null;
            console.log("Firebase listeners cleanup complete.");
        }
        
        // --- Event Listener Setup ---
        createRoomBtn.addEventListener('click', createRoom);
        roomNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') createRoom();
        });

        joinRoomBtn.addEventListener('click', joinRoom);
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') joinRoom();
        });

        const rejoinBtn = document.getElementById('rejoin-btn');
        if (rejoinBtn) {
            rejoinBtn.addEventListener('click', handleRejoin);
        }

        revealBtn.addEventListener('click', handleRevealVotes);
        resetBtn.addEventListener('click', handleResetVotes);

        function handleHashChange() {
            console.log("Hash changed detected:", window.location.hash);
            cleanupFirebaseListeners();
            checkUrlForRoom();
        }
        window.addEventListener('hashchange', handleHashChange);
        
        initializeAuth();

        if (cardSetSelect) {
            cardSetSelect.addEventListener('change', () => {
                if (cardSetSelect.value === 'custom') {
                    customCardValuesInput.classList.remove('hidden');
                    customCardValuesInput.focus();
                } else {
                    customCardValuesInput.classList.add('hidden');
                }
            });
        }
        
        function handleRejoin() {
            const roomIdToRejoin = currentRoomId;
            const userIdToRejoin = currentUserId;
            
            cleanupFirebaseListeners();

            if (!userIdToRejoin || !roomIdToRejoin) {
                console.error("Fehlende Informationen für den erneuten Beitritt (userId or roomId).");
                alert("Fehler: Wichtige Benutzer- oder Rauminformationen fehlen. Bitte laden Sie die Seite neu oder verwenden Sie den Link erneut.");
                window.location.hash = '';
                hideJoinOverlay();
                showScreen(initialScreen);
                return;
            }

            const kickFlagRef = ref(db, `rooms/${roomIdToRejoin}/kicked/${userIdToRejoin}`);

            console.log(`Versuche Kick-Flag für ${userIdToRejoin} in Raum ${roomIdToRejoin} zu entfernen...`);
            remove(kickFlagRef)
                .then(() => {
                    console.log("Kick-Flag erfolgreich entfernt. Zeige Beitritts-Overlay...");
                    checkUrlForRoom();
                })
                .catch(err => {
                    console.error("Fehler beim Entfernen des Kick-Flags:", err);
                    alert("Konnte den Kick-Status nicht entfernen. Bitte versuchen Sie es erneut.");
                });
        }

    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #fireworks-container {
            overflow: hidden;
        }
        .firework-particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: hsl(var(--hue), 100%, 50%);
            border-radius: 50%;
            opacity: 1;
            animation: firework-explode 0.8s ease-out forwards;
            box-shadow: 0 0 5px hsl(var(--hue), 100%, 50%), 0 0 10px hsl(var(--hue), 100%, 50%);
        }
        @keyframes firework-explode {
            0% {
                transform: scale(1) translate(0, 0);
                opacity: 1;
            }
            100% {
                transform: scale(0.5) translate(var(--tx), var(--ty));
                opacity: 0;
            }
        }
        #participants-list > div {
            margin-top: 1.25rem;
        }
         [title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            background-color: black;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 5px;
            z-index: 10;
        }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gradient-to-br from-indigo-100 via-purple-50 to-blue-100 min-h-screen">

    <div id="fireworks-container" class="fixed inset-0 pointer-events-none hidden z-[100]"></div>

    <div class="w-full max-w-4xl mx-auto mt-4">
        
        <div id="loading-screen" class="text-center p-8">
            <p class="text-gray-600 text-lg">Lade...</p>
        </div>

        <div id="initial-screen" class="hidden text-center bg-white p-8 rounded-lg shadow-md">
            <h1 class="text-3xl font-bold mb-6 text-gray-700">Planning Poker</h1>
            
            <input type="text" id="room-name" class="block w-full max-w-sm mx-auto p-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 mb-4" placeholder="Raumname">
            
            <div class="mb-4">
                <label for="card-set-select" class="block text-sm font-medium text-gray-700 mb-1 text-left max-w-sm mx-auto">Schätzwerte:</label>
                <select id="card-set-select" class="block w-full max-w-sm mx-auto p-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="default">Standard (0, ½, 1, 2, 3, 5, 8, ?, ☕)</option>
                    <option value="modified_fibonacci">Modified Fibonacci (0, ½, 1, 2, 3, 5, 8, 13, 20, 40, 100, ?, ☕)</option>
                    <option value="fibonacci">Fibonacci (0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ?, ☕)</option>
                    <option value="tshirts">T-Shirts (XS, S, M, L, XL, ?, ☕)</option>
                    <option value="custom">Eigene Auswahlwerte</option>
                </select>
                <input type="text" id="custom-card-values" class="hidden mt-2 block w-full max-w-sm mx-auto p-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Werte mit Komma trennen (z.B. 1,2,3,?,☕)">
            </div>

            <button id="create-room-btn" class="block w-full max-w-sm mx-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-md transition duration-150 ease-in-out">
                Raum erstellen
            </button>
        </div>

        <div id="join-overlay" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
            <div id="join-screen-content" class="bg-white p-8 rounded-lg shadow-md w-full max-w-sm text-center">
                 <h2 class="text-3xl font-bold mb-3 text-gray-700 text-left">Raum beitreten</h2>
                 <label for="username" class="block text-sm font-medium text-gray-700 mb-2 text-left">Dein Name:</label>
                 <input type="text" id="username" class="block w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 mb-4" placeholder="Benutzername">
                 <button id="join-room-btn" class="block w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-md transition duration-150 ease-in-out">
                    Beitreten
                 </button>
            </div>
        </div>

        <div id="room-screen" class="hidden bg-white p-6 rounded-lg shadow-lg w-full">
            <div class="flex justify-between items-center mb-2 flex-wrap">
                 <h2 id="room-title" class="text-2xl font-semibold text-gray-800 mr-4 mb-2 md:mb-0">Raum: ...</h2>
                 <div class="flex items-center">
                      <button id="copy-link-btn" title="Einladungslink kopieren" class="mr-2 p-2 rounded-full hover:bg-gray-200 text-gray-600 transition">
                          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                             <path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                          </svg>
                      </button>
                      <span id="invite-link-display" class="text-sm text-green-600 hidden"></span>
                 </div>
            </div>

            <h3 class="text-lg font-medium text-gray-700 mb-1">Teilnehmer:</h3>
            <div id="participants-list" class="flex justify-center min-h-[8rem] items-end overflow-x-auto pb-2">
                <div class="text-gray-500 italic whitespace-nowrap">Warte auf Teilnehmer...</div>
            </div>

            <div id="results-summary" class="hidden mb-2 p-2 bg-indigo-50 border border-indigo-200 rounded-md text-center">
            </div>

            <div class="text-center">
                <button id="reset-btn" class="hidden bg-gray-700 hover:bg-gray-800 mb-3 text-white font-bold py-3 px-6 rounded-md transition duration-150 ease-in-out min-w-[200px]">
                    Zurücksetzen
                </button>
            </div>

            <h3 class="text-lg font-medium text-gray-700 mb-3 text-center">Schätzung abgeben:</h3>
            <div id="voting-cards" class="flex flex-wrap justify-center gap-3">
            </div>

            <div class="text-center">
                <button id="reveal-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-md mt-5 transition duration-150 ease-in-out min-w-[200px]">
                    Stimmen aufdecken
                </button>
            </div>
        </div>

         <div id="kicked-screen" class="hidden text-center bg-white p-8 rounded-lg shadow-md">
            <h1 class="text-3xl font-bold mb-6 text-red-600">Du wurdest entfernt!</h1>
            <p class="mb-6 text-gray-700">Du wurdest aus diesem Raum entfernt.</p>
            <button id="rejoin-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-md transition duration-150 ease-in-out">
                Raum erneut beitreten
            </button>
         </div>
    </div>
</body>
</html>